# 股票问题：递推公式：dp[][]
## 对于可以无限制买入-售出的股票问题
    - dp[i][0]：第i天状态为买入时手中的余额。
      - dp[i][0] = max(dp[i-1][0],dp[i-1][1]-prices[i]). 在“第i-1天就已经买入”与“在第i天才买入（此时手中余额等同于第i-1天售出了股票后的余额）”的情况中选择最大值。
    - dp[i][1]：第i天状态为售出时手中的余额。
      - dp[i][1] = max(dp[i-1][1],dp[i-1][0]+prices[i])。在“第i-1天就已经售出”与“在第i天才售出（此时手中余额等同于第i-1天买入股票后的余额）”的情况中选择最大值。
    - 初始化：  
        第0天做第⼀次买⼊的操作，dp[0][1] = -prices[0];  
        第0天做第⼀次卖出的操作，dp[0][2] = 0   

## 对于有限制次数买入-售出的股票问题
    - dp[i][0]：表示不操作
    - dp[i][1]：第⼀次买⼊
      - 达到dp[i][1]状态，有两个具体操作：  
            操作⼀：第i天买⼊股票了，那么dp[i][1] = dp[i - 1][0] - prices[i]  
            操作⼆：第i天没有操作，⽽是沿⽤前⼀天买⼊的状态，即：dp[i][1] = dp[i - 1][1]  
            选最⼤的，所以 dp[i][1] = max(dp[i - 1][0] - prices[i], dp[i - 1][0]);
    - dp[i][2]：第⼀次卖出
      - 同理dp[i][2]也有两个操作：  
            操作⼀：第i天卖出股票了，那么dp[i][2] = dp[i - 1][1] + prices[i]  
            操作⼆：第i天没有操作，沿⽤前⼀天卖出股票的状态，即：dp[i][2] = dp[i - 1][2]  
            所以dp[i][2] = max(dp[i - 1][1] + prices[i], dp[i - 1][2])

    - dp[i][3]：第二次买⼊
    - dp[i][4]：第二次卖出
      - 同理可推出剩下状态部分：  
            dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);  
            dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);
    
    - 初始化：
        第0天没有操作，这个最容易想到，就是0，即：dp[0][0] = 0;  
        第0天做第⼀次买⼊的操作，dp[0][1] = -prices[0];  
        第0天做第⼀次卖出的操作，dp[0][2] = 0  
        第0天第⼆次买⼊操作，初始化为：dp[0][3] = -prices[0];  
        同理第0天第⼆次卖出初始化dp[0][4] = 0
- 更多种状态的股票问题。如果交易股票有次数限制，那么状态数量需要根据具体次数进行调整(2k+1个状态，其中0是未操作，然后是第一次买入、第一次卖出、第二次买入、第二次卖出...第k次买入，第k次卖出)；如果交易没有次数限制，那么状态数量只需设置两个：持有和未持有股票

## 关于有冷却的股票问题（旧解法，五个状态）：

    - 状态一：保持买入：dp[0][0] = -prices[0]; 
      - 状态在前一天已是“保持买入”与前一天为“今天买入”中选择最大：dp[i][0] = max(dp[i-1][0],dp[i-1][1]);
    - 状态二：今天买入：dp[0][1] = -prices[0]; 
      - 状态在前一天是“冷却状态”或者前一天已经是“保持售出”状态中选择最大：dp[i][1] = max(dp[i-1][4] - prices[i], dp[i-1][2] - prices[i]);
    - 状态三：保持卖出：dp[0][2] = 0; 
      - 状态在前一天是”冷却状态”或者前一天是“保持卖出状态”中选择最大（前一天不可能是状态4）：dp[i][2] = max(dp[i-1][4], dp[i-1][2]);
    - 状态四：今天卖出：dp[0][3] = 0; 
      - 状态在前一天是“保持买入状态”或前一天是“今天买入状态”中选择一个：dp[i][3] = max(dp[i-1][1] + prices[i], dp[i-1][0]+prices[i]);
    - 状态五：冷却：dp[0][4] = 0; 
      - 状态只可能是前一天是“今天卖出”状态：dp[i][4] = dp[i-1][3];
    - 初始化：  
        dp[0][0] = -prices[0]; //保持买入  
        dp[0][1] = -prices[0]; //今天买入  
        dp[0][2] = 0; //保持卖出  
        dp[0][3] = 0; //今天卖出  
        dp[0][4] = 0; //冷冻

## 关于有冷却的股票问题（新解法，更简便三个状态）：        
```
1. 定义dp[ i ][ j ]: 表示第i天在状态j时的最大利润
   1. i 表示天数
   2. j表示状态，0持有，1今天之前就已经卖出去了而导致当天未持有，因此明天不会处于冷冻期，2由于今天刚卖完股票而导致当天未持有，明天会处于冷冻期。
2. base case：第一天如果是持有状态，那么最大利润是-prices[ 0 ]，其他两个状态都是0.
3. 递推公式：
   1. 今天持有股票：dp[ i ][ 0 ] = max(dp[ i - 1 ][ 0 ], dp[ i - 1 ][ 1 ] - prices[ i - 1 ]);
      1. 那么前一天要么是已经持有股票：dp[ i - 1 ][ 0 ]
      2. 要么是前一天未持有股票且不处于刚卖完的状态，此时今天的最大利润就是前一天的“未持有股票且不处于刚卖完的状态”的最大利润加今日的股票价格（冷冻期）：dp[ i - 1 ][ 1 ] - prices[ i - 1 ]。
      3. **为什么前一天不能处于刚卖完的状态？** 如果前一天处于刚卖完的状态，那么今天还是冷冻期，无法交易。
   2. 如果今天未持有股票且不处于刚卖完的状态：dp[ i ][ 1 ] = max(dp[ i - 1 ][ 1 ], dp[ i - 1 ][ 2 ])
      1. 那么前一天要么就是未持有股票且也不处于刚卖完的状态；dp[ i - 1 ][ 1 ]
      2. 要么就是未持有股票但是处于刚买完的状态，dp[ i - 1 ][ 2 ]
   3. 如果今天未持有股票且处于刚卖完的状态：dp[ i ][ 2 ] = dp[ i - 1 ][ 0 ] + prices[ i - 1 ];
      1. 那么前一天一定持有股票，今天的最大利润就是前一天的持有股票状态加今天把股票卖掉的钱，dp[ i - 1 ][ 0 ] + prices[ i - 1 ]
   4. 遍历顺序：从前到后遍历
   5. 返回值：我们不确定最后一天是处于刚好卖掉股票的（冷冻）状态还是处于最后一天的前一天就已经卖掉股票的状态，所以从两个之中选一个大的返回，return max(dp[prices.size()][1], dp[prices.size()][2]);
```
    
            
            
            
        