# [123. 买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)
### 题目：
给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

示例 1:
```
输入：prices = [3,3,5,0,0,3,1,4]
输出：6
解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
```
示例 2：
```
输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```
示例 3：
```
输入：prices = [7,6,4,3,1] 
输出：0 
解释：在这个情况下, 没有交易完成, 所以最大利润为 0。
```
示例 4：
```
输入：prices = [1]
输出：0
```
 

提示：
```
1 <= prices.length <= 10^5
0 <= prices[i] <= 10^5
```
来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

### 思路：
1. dp[ i ][ j ]表示第i天在j状态下的最大利润为dp[ i ][ j ]。j为[0,4],其中0为未操作，1为第一次买入，2为第一次卖出，3为第二次买入，4为第二次卖出。
2. base case：在第一天的其他三个状态（未操作，第一次卖出，第二次卖出）最终导致的最大利润结果均为0
3. 递推公式：在第i天，我们只可能在0：为未操作，1：第一次买入，2：第一次卖出，3：第二次买入，4：第二次卖出中的其中一种。
   1. 第i天未操作的最大利润永远是0，因为该状态只会被 “1:第一次买入”使用，其他的状态都不可能直接从0跳跃得到dp[i][0] = dp[i-1][0];
   2. 如果第i天处于第一次买入股票的状态，那么前一天只可能是两种情况：一是第i-1天没有买股票，今天才买入股票；二是第i-1天就已经第一次买入股票了，此时只是持有他，dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i-1]);
   3. 如果第i天处于第一次卖出股票的状态，那么前一天只可能是两种情况：一是第i-1天已经卖出了股票，今天只是保持卖出的状态；二是第i-1天没有卖出股票，今天才卖出股票，dp[i][2] = max(dp[i-1][2], dp[i-1][1] + prices[i-1]); 
   4. 如果第i天处于第二次买入股票的状态，那么前一天只可能是两种情况：一是第i-1天没有买第二支股票，今天才买入第二支股票；二是第i-1天就已经第二次买入股票了，此时只是持有他，dp[i][3] = max(dp[i-1][3], dp[i-1][2] - prices[i-1]);
   5. 如果第i天处于第二次卖出股票的状态，那么前一天只可能是两种情况：一是第i-1天已经卖出了第二支股票，今天只是保持卖出的状态；二是第i-1天没有卖出股票，今天才卖出股票，dp[i][4] = max(dp[i-1][4], dp[i-1][3] + prices[i-1]);
4. 递归顺序：从小到大遍历prices
5. 不论如何最后一天一定会卖出两只股票（卖出两次得到的利润一点大于等于卖出一次得到的利润），所以直接返回卖出2次的状态即可

[------------>代码随想录题目详解戳这里](https://programmercarl.com/0123.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII.html)
### 难点：
- 多个状态的遍历以及状态之间的转换关系（比如1只能有0得到，2只能由1得到......4只能由3得到）

### 代码：  
```
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        vector<vector<int>> dp(prices.size()+1, vector<int>(5,0));//dp[ i ][ j ]表示第i天在j状态下的最大利润为dp[ i ][ j ]。j为[0,4],其中0为未操作，1为第一次买入，2为第一次卖出，3为第二次买入，4为第二次卖出。
        //base case：在第一天的其他三个状态（未操作，第一次卖出，第二次卖出）最终导致的最大利润结果均为0
        dp[1][1] = -prices[0];
        dp[1][3] = -prices[0];

        for(int i = 2; i <= prices.size(); i++){
            dp[i][0] = dp[i-1][0];    //未操作的金额就是前一天的最大利润
            dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i-1]);   //如果第i天处于第一次买入股票的状态，那么前一天只可能是两种情况：一是第i-1天没有买股票，今天才买入股票；二是第i-1天就已经第一次买入股票了，此时只是持有他
            dp[i][2] = max(dp[i-1][2], dp[i-1][1] + prices[i-1]);   //如果第i天处于第一次卖出股票的状态，那么前一天只可能是两种情况：一是第i-1天已经卖出了股票，今天只是保持卖出的状态；二是第i-1天没有卖出股票，今天才卖出股票
            dp[i][3] = max(dp[i-1][3], dp[i-1][2] - prices[i-1]);   //如果第i天处于第二次买入股票的状态，那么前一天只可能是两种情况：一是第i-1天没有买第二支股票，今天才买入第二支股票；二是第i-1天就已经第二次买入股票了，此时只是持有他
            dp[i][4] = max(dp[i-1][4], dp[i-1][3] + prices[i-1]);//如果第i天处于第二次卖出股票的状态，那么前一天只可能是两种情况：一是第i-1天已经卖出了第二支股票，今天只是保持卖出的状态；二是第i-1天没有卖出股票，今天才卖出股票
        }
        return dp[prices.size()][4];    //不论如何最后一天一定会卖出两只股票（卖出两次得到的利润一点大于等于卖出一次得到的利润），所以直接返回卖出2次的状态即可
    }
};
```


# [188. 买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)
### 题目：
给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

示例 1：
```
输入：k = 2, prices = [2,4,1]
输出：2
解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。
```
示例 2：
```
输入：k = 2, prices = [3,2,6,5,0,3]
输出：7
解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。
     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。
```

提示：
```
0 <= k <= 100
0 <= prices.length <= 1000
0 <= prices[i] <= 1000
```
来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

### 思路：
1. dp[ i ][ j ]表示第i天在j状态下的最大利润为dp[ i ][ j ]。j为[0,4],其中0为未操作，1为第一次买入，2为第一次卖出，3为第二次买入，4为第二次卖出...2*k-1为第k次买入，2*k为第k次卖出。
2. base case：用i遍历k，当i为奇数时，我们买入。在第1天的买入时，余额为-prices[0]。
3. 递推公式：在第i天，我们只可能在0：为未操作，1：第一次买入，2：第一次卖出，3：第二次买入，4：第二次卖出，...2*k-1：第k次买入，2*k：第k次卖出中的其中一种。
   1. 第i天未操作的最大利润永远是0，因为该状态只会被 “1:第一次买入”使用，其他的状态都不可能直接从0跳跃得到dp[i][0] = dp[i-1][0]; 此递推可以不写，因为初始化已经完成了这部分操作。
   2. 如果第i天处于第j次买入股票的状态，则 j 为奇数，（状态j有 k 种），那么前一天只可能是两种情况：
      1. 一是第i-1天没有买股票，今天才买入股票，那么今日的最大利润是前一天的前一天的卖出状态减去今天的princes，因为今天买入了；dp[ i ][ j ] = dp[i - 1][ j - 1 ] - prices[i - 1])
      2. 二是第i-1天就已经买入股票了，此时只是持有他，那么今日的最大利润是前一天的状态 j 时的最大利润，dp[ i ][ j ] = dp[i - 1][ j ]
      3. dp[ i ][ j ] = max(dp[i - 1][ j ], dp[i - 1][ j - 1 ] - prices[i - 1]);
   3. 如果第i天处于第j次卖出股票的状态，那么前一天只可能是两种情况：
      1. 一是第i-1天已经卖出了股票，今天只是保持卖出的状态；dp[i - 1][ j ]
      2. 二是第i-1天没有卖出股票，今天才卖出股票，那么前一天一定是买入状态，今天的最大利润是前一天的买入状态加今日的prices，因为今日卖出了。dp[ i ][ j ] = dp[i - 1][j - 1] + prices[i - 1]
      3. dp[i][2] = max(dp[i - 1][ j ], dp[i - 1][j - 1] + prices[i - 1])
   4. 
4. 递归顺序：从小到大遍历prices
5. 不论如何最后一天一定会卖出k只股票（卖出两次得到的利润一点大于等于卖出一次得到的利润），所以直接返回卖出k次的状态即可

[------------>代码随想录题目详解戳这里](https://programmercarl.com/0188.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV.html)
### 难点：


### 代码：  
```
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        if(prices.size() == 0 || prices.size() == 1)  return 0;
        vector<vector<int>> dp(prices.size()+1, vector<int>(2*k+1, 0));//dp[i][j]表示第i天在状态j时的最大利润, 
        //base case，在第1天第i次买入，那么第i次买入的价格就是-prices[0]
        for(int i = 1; i < 2*k+1; i += 2){
            if(i % 2 != 0)
                dp[1][i] = -prices[0];
        }//当k = 3， 有 (0, 1, 2, 3, 4, 5, 6)7个状态，其中1，3，5位买入状态，此时金额为-prices[i/2]
        //当k = 2，有（0，1，2，3，4）5个状态，其中1，3是买入状态，2，4是卖出状态

        for(int i = 2; i < prices.size() + 1; i++){
            for(int j = 1; j < 2*k+1; j++){
                if(j % 2 != 0){//奇数是买入状态
                    dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] - prices[i-1]);
                }
                else{//偶数是卖出状态
                    dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i-1]);
                }
            }
        }
        return dp[prices.size()][2*k];
    }
};
```